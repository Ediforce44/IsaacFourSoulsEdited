
local ACTIVE_BUTTON_INDEX = 1

function onLoad(saved_data)
    self.createButton({
      click_function = "switchBuilderMode",
      function_owner = self,
      label          = "",
      position       = {1.5, 1, -0.12},
      width          = 300,
      height         = 300,
      color          = {1, 1, 1},
    })

    if saved_data ~= "" then
        local loaded_data = JSON.decode(saved_data)
        if loaded_data[1] == true then
            switchBuilderMode()
        end
    end
end

function onSave()
    return JSON.encode({isDeckBuilderON()})
end

function isDeckBuilderON()
    local activeButton = self.getButtons()[ACTIVE_BUTTON_INDEX]
    return (activeButton.label ~= "")
end

function switchBuilderMode()
    local newLabel = ""
    if not isDeckBuilderON() then
        newLabel = "âœ“"
    end
    self.editButton({index=ACTIVE_BUTTON_INDEX-1, label=newLabel, font_color={0, 0, 0}, font_size=200})
end

------------------------------------------------------------------------------------------------------------------------
--------------------------------------------      Deck Builder        --------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

DECK_BUILDER_MODE = {
    NORMAL  = 1,
    DRAFT   = 2
}

local DUMMY_CARDS = {
    TREASURE = {"20478b", "de6fa6"},
    LOOT = {"fc7f84", "d8bf8b"},
    MONSTER = {"6f7d81", "ad45a5"}
}

local DECK_TREASURE = {
    {
        T_ACTIVE  = 40,
        T_PASSIVE = 44,
        T_PAID    = 10,
        T_ONE_USE = 5,
        T_SOUL    = 1
    },
    {
        T_ACTIVE  = 40,
        T_PASSIVE = 44,
        T_PAID    = 10,
        T_ONE_USE = 5,
        T_SOUL    = 1
    }
}

local DECK_LOOT = {
    {
        L_TAROT_MISC    = 23,
        L_TRINKET       = 11,
        L_PILL          = 3,
        L_RUNE          = 3,
        L_BUTTER_BEAN   = 5,
        L_BOMB          = 6,
        L_BATTERY       = 6,
        L_DICE_SHARD    = 3,
        L_SOUL_HEART    = 2,
        L_LOST_SOUL     = 1,
        L_NICKEL        = 6,
        L_FOUR_CENT     = 12,
        L_THREE_CENT    = 11,
        L_TWO_CENT      = 6,
        L_ONE_CENT      = 2
    },
    {
        L_TAROT_MISC    = 22,
        L_TRINKET       = 10,
        L_PILL          = 2,
        L_RUNE          = 3,
        L_BUTTER_BEAN   = 5,
        L_BOMB          = 5,
        L_BATTERY       = 5,
        L_DICE_SHARD    = 3,
        L_SOUL_HEART    = 2,
        L_LOST_SOUL     = 1,
        L_NICKEL        = 5,
        L_FOUR_CENT     = 10,
        L_THREE_CENT    = 10,
        L_TWO_CENT      = 5,
        L_ONE_CENT      = 2
    }
}

local DECK_MONSTER = {
    {
        M_BOSS        = 30,
        M_EPIC        = 1,
        M_BASIC       = 30,
        M_CURSED      = 9,
        M_HOLY_CHARMED= 9,
        M_GOOD        = 8,
        M_BAD         = 8,
        M_CURSE       = 5
    },
    {
        M_BOSS        = 30,
        M_EPIC        = 1,
        M_BASIC       = 30,
        M_CURSED      = 9,
        M_HOLY_CHARMED= 9,
        M_GOOD        = 8,
        M_BAD         = 8,
        M_CURSE       = 5
    }
}

local B_TOTAL_DECK_COUNT = 5
local B_waitingDecks = {}

local function getDeckFromTable(name)
    for _, obj in ipairs(getObjectsWithTag("Deck")) do
        if obj.getName() == name then
            return obj
        end
    end
    return nil
end

local function buildDeck(preDeckGUIDs, tagTable)
    tagTable["EMPTY"] = 200
    local buildDeck = nil
    for type, amount in pairs(tagTable) do
        if preDeckGUIDs[type] ~= nil then
            local preDeck = getObjectFromGUID(preDeckGUIDs[type])
            if preDeck.tag == "Deck" then
                if amount == 1 then
                    preDeck = preDeck.takeObject()  -- For the edge case that only one card should be choosen
                else
                    preDeck.cut(preDeck.getQuantity() - amount)
                end
            end

            --TODO Fix bug if the first preDeck is only one card
            if buildDeck == nil then
                buildDeck = preDeck
            else
                buildDeck.putObject(preDeck)
            end
        end
    end
    return buildDeck
end

local function deckBuildBarrier(deckType, deck)
    B_waitingDecks[deckType] = deck
    local waitCount = 0
    for _, _ in pairs(B_waitingDecks) do
        waitCount = waitCount + 1
    end
    if waitCount >= B_TOTAL_DECK_COUNT then
        getObjectFromGUID("195d79").call("decksBuilt", B_waitingDecks)
        B_waitingDecks = {}
    end
end

local function finishTreasureDeck(treasureDeck)
    treasureDeck.setName("Treasure Deck")
    deckBuildBarrier("TREASURE", treasureDeck)
end

local function finishLootDeck(lootDeck)
    lootDeck.setName("Loot Deck")
    deckBuildBarrier("LOOT", lootDeck)
end

local function finishMonsterDeck(monsterDeck)
    monsterDeck.setName("Monster Deck")
    deckBuildBarrier("MONSTER", monsterDeck)
end

local function combine(startDeck, deckGUIDs)
    for _, guid in pairs(deckGUIDs) do
        startDeck.putObject(getObjectFromGUID(guid))
    end
end

local function buildTreasureDeck(mode, preTreasureDecks)
    local treasureDeck = nil
    local treasureZone = getObjectFromGUID(Global.getTable("ZONE_GUID_DECK").TREASURE)

    if isDeckBuilderON() then
        treasureDeck = buildDeck(preTreasureDecks, DECK_TREASURE[mode])
    else
        treasureDeck = getObjectFromGUID(preTreasureDecks.T_ACTIVE)
        combine(treasureDeck, preTreasureDecks)
    end
    treasureDeck.setPositionSmooth(Global.getTable("DECK_POSITION").TREASURE, false)
    treasureDeck.setRotationSmooth({180, 0, 0}, false)
    treasureDeck.interactable = true
    Wait.time(function() finishTreasureDeck(treasureDeck) end, 2)
end

local function buildLootDeck(mode, preLootDecks)
    local lootDeck = nil
    local lootZone = getObjectFromGUID(Global.getTable("ZONE_GUID_DECK").LOOT)

    if isDeckBuilderON() then
        lootDeck = buildDeck(preLootDecks, DECK_LOOT[mode])
    else
        lootDeck = getObjectFromGUID(preLootDecks.L_TAROT_MISC)
        combine(lootDeck, preLootDecks)
    end
    lootDeck.setPositionSmooth(Global.getTable("DECK_POSITION").LOOT, false)
    lootDeck.setRotationSmooth({180, 0, 0}, false)
    lootDeck.interactable = true
    Wait.time(function() finishLootDeck(lootDeck) end, 2)
end

local function buildMonsterDeck(mode, preMonsterDecks)
    local monsterDeck = nil
    local monsterZone = getObjectFromGUID(Global.getTable("ZONE_GUID_DECK").MONSTER)

    if isDeckBuilderON() then
        monsterDeck = buildDeck(preMonsterDecks, DECK_MONSTER[mode])
    else
        monsterDeck = getObjectFromGUID(preMonsterDecks.M_BASIC)
        combine(monsterDeck, preMonsterDecks)
    end
    monsterDeck.setPositionSmooth(Global.getTable("DECK_POSITION").MONSTER, false)
    monsterDeck.setRotationSmooth({180, 0, 0}, false)
    monsterDeck.interactable = true
    Wait.time(function() finishMonsterDeck(monsterDeck) end, 2)
end

local function buildRoomDeck(mode, preRoomDecks)
    local roomDeck = nil
    for _, guid in pairs(preRoomDecks) do
        local preRoomDeck = getObjectFromGUID(guid)
        --TODO Fix bug if the first preDeck is only one card
        if preRoomDeck.tag == "Deck" then
            if roomDeck == nil then
                roomDeck = preRoomDeck
            else
                roomDeck.putObject(preRoomDeck)
            end
        end
    end
    roomDeck.interactable = true
    roomDeck.setPositionSmooth(Global.getTable("DECK_POSITION").ROOM, false)
    roomDeck.setRotationSmooth({180, 0, 0}, false)
    roomDeck.setName("Room Deck")
    deckBuildBarrier("ROOM", roomDeck)
end

local function buildBonusSoulDeck(mode, preBonusSoulDecks)
    local bonusSoulDeck = nil
    for _, guid in pairs(preBonusSoulDecks) do
        local preBonusSoulDeck = getObjectFromGUID(guid)
        --TODO Fix bug if the first preDeck is only one card
        if preBonusSoulDeck.tag == "Deck" then
            if bonusSoulDeck == nil then
                bonusSoulDeck = preBonusSoulDeck
            else
                bonusSoulDeck.putObject(preBonusSoulDeck)
            end
        end
    end
    bonusSoulDeck.interactable = true
    bonusSoulDeck.setPositionSmooth(Global.getTable("DECK_POSITION").BONUS_SOUL, false)
    bonusSoulDeck.setRotationSmooth({0, 270, 180}, false)
    bonusSoulDeck.setName("Bonus-Soul Deck")
    deckBuildBarrier("BONUS_SOUL", bonusSoulDeck)
end

function buildDecks(params)
    local buildingMode = 1
    if params.buildingMode ~= nil then
        buildingMode = params.buildingMode
    end
    if params.preDecks == nil then
        printToAll("[fdd835][WARNING][-] Wrong parameters in Deck Builder function 'buildDecks()'.")
    end
    buildTreasureDeck(buildingMode, params.preDecks.TREASURE)
    buildLootDeck(buildingMode, params.preDecks.LOOT)
    buildMonsterDeck(buildingMode, params.preDecks.MONSTER)

    buildRoomDeck(buildingMode, params.preDecks.ROOM)
    buildBonusSoulDeck(buildingMode, params.preDecks.BONUS_SOUL)
end